## 重温 C/C++ 内存对齐

为什么要内存对齐？我个人认为系统在读取数据的时候不是一个一个字节的读取，而是按页来把数据读到内存中。所以为了能一次读取完整的数据，避免一块内存在读取的时候出现横跨两页，这样想要读取这块内存需要两次读取并且通过算法合并。有时候单方面过于优化并不能提升整体。所以系统在存放数据的时候，会让数据完整的存放在一页中，哪怕这样会产生浪费和空间碎片化。

对齐规则，在结构体中，内存长度会是长度最大的类型（不包含数据）的倍数。例如：

```c
struct TData{
	int a;
	double b;
	char c;
};
// 其内存分配如下
/—— —— —— ——/—— —— —— ——/—— —— —— ——/
  a(8字节)	b(8字节)     c(8字节)
```

虽然 **sizeof(int) + sizeof(double) + sizeof(c)** = 4 +  8 + 1 = 13, 但是程序实际分配给这个类型的内存为24字节。这是因为 **a** 和 **c** 需要独自占用一块和 **b** 长度一样大小的内存。但当我们调整 结构体成员变量后，例如:

```c
struct TData{
	int a;
	char c;
    double b;
};
// 其内存分配如下, a 和 c 共用一块内存
/—— —— —— ——/—— —— —— ——/
a + c(8字节)	b(8字节)   
```

通过调整成员位置，使成员**a**和**c**共用一块内存，比之前减少了8字节的内存开销。这在程序需要做优化时是个比较好的切入点。

